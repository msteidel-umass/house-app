<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="./libs/d3.js"></script>
    <!-- <script src="./libs/topojson.v3.js"></script> -->
    <link rel="stylesheet" href="./styles.css">
</head>

<body>
    <div id="control_overlay"></div>
    <div id="tooltip"></div>
    <div id="home_values" class="map"></div>
    <div id="incomes" class="map"></div>
    <div id="combined" class="map"></div>
</body>

<script>
    // define geo json & csv file(s)
    const US_COUNTIES = "./data/us_counties_geo.json"
    const HOME_VALS = "./data/median_house_values.csv"
    const INCOMES = "./data/median_incomes.csv"
    // define window dim vars
    const WIDTH = window.innerWidth;
    const HEIGHT = window.innerHeight;
    // const array contains html div ID names containing each map (SVG)
    const MAP_DIVS = document.getElementsByClassName("map");

    // Vars used to specifcy the specific years retrieve housing/income data
    var valueStartYear = 2020;
    var valueEndYear = 2020;
    var incomeStartYear = 2020;
    var incomeEndYear = 2020;
    var combinedStartYear = 2020;
    var combinedEndYear = 2020;
    // Dictionaries which will hold re-calculated (home,income,health) data values for each county
    // These are what's used used to fill/re-color each SVG map
    var medianValueRates = {};
    var medianIncomeRates = {};
    var combinedRates = {};
    // Init vars to keep track of the actively displayed div (SVG) and corresponding map data
    var activeMap = null;
    var activeRateData = {};

    // Load the data as a promise
    Promise.all([
        d3.json(US_COUNTIES),
        d3.csv(HOME_VALS),
        d3.csv(INCOMES),
    ]).then(data => {
        // Constants to store each set of imported data after files are loaded
        const geoJsonCounties = data[0];
        const homeValues = data[1];
        const incomeValues = data[2];

        // Initialize each dict with every county's FIPS No., to be used as an index
        for (var key in homeValues[0]) {
            medianValueRates[key] = null;
            medianIncomeRates[key] = null;
            combinedRates[key] = null;
        }
        // Define the D3 projection, size, and scale constants and geoPathGenerator
        const projection = d3.geoAlbers()
            .translate([WIDTH / 2, HEIGHT / 2]) // center map
            .scale(WIDTH);                      // set inital scale to screen width
        const geoPathGen = d3.geoPath().projection(projection);
        // Allow for D3 zooming
        const zoom = d3.zoom()
            .scaleExtent([1, 15])                                                            // zoom scale limits
            .translateExtent([[WIDTH * -.5, HEIGHT * -1.5], [WIDTH * 1.25, HEIGHT * 1.5]]) // pan scale limits
            .on('zoom', handleZoom);                                                        // on a zoom event, call handleZoom
        // each of these will update their respective map's rate data
        const tooltip = d3.select("#tooltip");
        // D3 coloring interpolation using previously defined coloring scale - uses D3 Red-to-Blue coloring Scheme
        var colorInterpolator = d3.interpolateRdBu;
        // Tool tip html.  Slightly different display of data, depending on
        // whether or not the start and end year is the same
        function updateToolTip(d) {
            var toolTipData = "";
            var rateProperty = "";
            var numProperty = "";
            var startYear = "";
            var endYear = "";
            var activeRateData = {};
            if (activeMap == MAP_DIVS[0].id) {
                rateProperty = "Change in Median Home Value:";
                numProperty = "Median Home Value:";
                startYear = valueStartYear;
                endYear = valueEndYear;
                activeRateData = medianValueRates;
            }
            else if (activeMap == MAP_DIVS[1].id) {
                rateProperty = "Change in Median Income:";
                numProperty = "Median Income:";
                startYear = incomeStartYear;
                endYear = incomeEndYear;
                activeRateData = medianIncomeRates;
            }
            else if (activeMap == MAP_DIVS[2].id) {
                rateProperty = "Apprx. Housing Market Inflation:";
                startYear = combinedStartYear;
                endYear = combinedEndYear;
                for (var key in combinedRates) {
                    activeRateData[key] = combinedRates[key] * -1;
                }
            }
            if (startYear == endYear) {
                toolTipData =
                    "<div class=\"p\">County / Municipality: " + "</div > " +
                    "<div class=\"v\">" + d.properties['NAME'] + "</div>" +
                    "<div class=\"p\">State / Territory:</div>" +
                    "<div class=\"v\">" + d.properties['STATE_NAME'] + "</div>" +
                    "<div id=\"year\">Year: " + String(startYear) + "</div>" +
                    "<div class=\"p\">" + rateProperty + "</div>" +
                    "<div class=\"v\">" + String(activeRateData[d.properties["GEO_ID"]].toFixed(2)) + " %</div>" +
                    "<div class=\"p\">" + numProperty + "</div>" +
                    "<div class=\"v\">" + "hello" + "</div>"
            }
            else {
                toolTipData =
                    "<div id=\"property1\">County / Municipality:" + "</div>" +
                    "<div id=\"value1\">" + d.properties['NAME'] + "</div>" +
                    "<div id=\"property2\">State / Territory:" + "</div>" +
                    "<div id=\"value2\">" + d.properties['STATE_NAME'] + "</div>" +
                    "<div id=\"propert3y\">" + rateProperty + "</div>" +
                    "<div id=\"value3\">" + String(activeRateData[d.properties["GEO_ID"]].toFixed(2)) + " %</div>"
            }

            return toolTipData;
        }


        // Append a SVG element to each map display div
        var svg = d3.selectAll("#" + MAP_DIVS[0].id + ",#" + MAP_DIVS[1].id + ",#" + MAP_DIVS[2].id).append("svg")
            .attr("width", "100vw")
            .attr("height", "100vh")
            .call(zoom)
        // Svg grouping element constant--path elements are appended to a group
        var g = svg.append("g");
        // Build the SVG w/ tooltip feature
        // Append geo data and "path" elements to construct initial map SVGs.
        g.selectAll("path")
            .data(geoJsonCounties.features)
            .enter()
            .append("path")
            .attr("d", (d) => { return geoPathGen(d); })
            .on("mouseenter", (m, d) => {
                tooltip.transition()
                    .delay(200)
                    .style("display", "grid")
                    .style("opacity", .9)
                tooltip.html(updateToolTip(d))          // Passes each path to updateToolTip which returns html to populate
                    .style("left", m.clientX + "px")
                    .style("top", m.clientY + "px");
            })
            .on("mouseleave", (m, d) => {
                tooltip.transition()
                    .style("display", "none")
            })

        // Function will update the % change in median home values between two dates for all counties
        function calcValueRates(start, end) {
            var rates = {}
            var start_year_d = {}
            var end_year_d = {}
            // Retrieve data sets for corresponding years
            homeValues.forEach(d => {
                if (d["Year"] == start) {
                    start_year_d = d;
                }
                if (d["Year"] == end) {
                    end_year_d = d;
                }
            });
            // Perform data lookups & calculate the % difference
            for (var key in homeValues[0]) {
                rates[key] = ((end_year_d[key] - start_year_d[key]) / start_year_d[key]) * 100
            }
            return rates;
        }

        // Function will update the % change in median income between two dates for all counties
        function calcIncomeRates(start, end) {
            var rates = {}
            var start_year_d = {}
            var end_year_d = {}
            incomeValues.forEach(d => {
                if (d["Year"] == start) {
                    start_year_d = d;
                }
                if (d["Year"] == end) {
                    end_year_d = d;
                }
            });
            for (var key in incomeValues[0]) {
                rates[key] = ((end_year_d[key] - start_year_d[key]) / start_year_d[key]) * 100
            }
            console.log("Income:", rates)
            return rates;
        }

        // Function will determine the housing market health between two dates by 
        // comparing change over time of median home price-to-income ratios for all counties
        function calcCombinedRates(start, end) {
            var startValue_d = null;
            var endValue_d = null;
            var startIncome_d = null;
            var endIncome_d = null;
            var rates = {}
            // Get both median home value and median income data for both years for all counties
            homeValues.forEach(d => {
                if (d["Year"] == start) {
                    startValue_d = d;
                }
                if (d["Year"] == end) {
                    endValue_d = d;
                }
            });
            incomeValues.forEach(d => {
                if (d["Year"] == start) {
                    startIncome_d = d;
                }
                if (d["Year"] == end) {
                    endIncome_d = d;
                }
            });
            // Caluclate the initial and the final homeprice-to-income ratio's for all counties
            var p2i_initial = {}
            var p2i_final = {}
            for (var key in startValue_d) {
                p2i_initial[key] = startValue_d[key] / startIncome_d[key]
            }
            for (var key in endValue_d) {
                p2i_final[key] = endValue_d[key] / endIncome_d[key]
            }
            // Calculate the overall housing market inflation rates between the timeframe
            for (var key in p2i_initial) {
                rates[key] = ((p2i_final[key] - p2i_initial[key]) / p2i_initial[key]) * 100;
            }
            return rates;
        }

        function dataUpdateHandler(start, end) {
            if (activeMap == MAP_DIVS[0].id) {
                valueStartYear = start;
                valueEndYear = end;
                medianValueRates = calcValueRates(start, end);
                updateMap(medianValueRates)
            }
            else if (activeMap == MAP_DIVS[1].id) {
                incomeStartYear = start;
                incomeEndYear = end;
                medianIncomeRates = calcIncomeRates(start, end);
                updateMap(medianIncomeRates);
            }
            else if (activeMap == MAP_DIVS[2].id) {
                console.log("ran")
                combinedStartYear = start;
                combinedEndYear = end;
                combinedRates = calcCombinedRates(start, end);
                updateMap(combinedRates);
            }
        }

        // Function updates global start & end year vars (set by range slider cntrls)
        // Then makes a call to updateMap(), which makes calls to updateData and colorMap
        function changeYears(start, end) {
            dataUpdateHandler(start, end);
        }
        // colorMap, will first make a call to the updateDataHandler to refresh the data it needs to re-color
        function updateMap(rateData) {
            // Take extent of new data range
            var extent = d3.extent(Object.values(rateData));
            console.log(extent);
            // Update coloring scale based on the new data
            var sorted = Object.values(rateData).sort(d3.ascending);
            sorted.map(d => { return d.toFixed(2) });
            console.log(sorted);
            let scale = d3.scaleDiverging()
                .domain([extent[0], 0, extent[1]], (d) => {       //a min to max scale with '0' value is nuetral
                    return d;
                });
            // Color the map
            colorMap(scale, rateData);
        }

        function colorMap(scale, rateData) {
            console.log("Coloring")
            // Color (fill) the map
            d3.selectAll("#" + activeMap + " path")
                .attr("fill", (d) => {
                    for (var key in rateData) {
                        if (d.properties["GEO_ID"] == key) {
                            //console.log(d.properties["NAME"] + ": " + rateData[key]);
                            return colorInterpolator(scale(rateData[key]));
                        }
                    }
                });
        }

        function handleZoom(e) {
            d3.select("#" + activeMap + ' svg g')
                .attr('transform', e.transform);
        }

        // USER INTERFACE CONTROL FUNCTION DEFINITIONS:

        // Define toggle map btn controls--changes the 'active' map div
        function toggleMap(divName) {
            if (divName == MAP_DIVS[0].id && activeMap != MAP_DIVS[0].id) {
                document.getElementById(MAP_DIVS[0].id).style.display = "initial";
                document.getElementById(MAP_DIVS[1].id).style.display = "none";
                document.getElementById(MAP_DIVS[2].id).style.display = "none";
                activeMap = MAP_DIVS[0].id;
                setSliderDates(valueStartYear, valueEndYear);
            }
            else if (divName == MAP_DIVS[1].id && activeMap != MAP_DIVS[1].id) {
                document.getElementById(MAP_DIVS[0].id).style.display = "none";
                document.getElementById(MAP_DIVS[1].id).style.display = "initial";
                document.getElementById(MAP_DIVS[2].id).style.display = "none";
                activeMap = MAP_DIVS[1].id;
                setSliderDates(incomeStartYear, incomeEndYear);
            }
            else if (divName == MAP_DIVS[2].id && activeMap != MAP_DIVS[2].id) {
                document.getElementById(MAP_DIVS[0].id).style.display = "none";
                document.getElementById(MAP_DIVS[1].id).style.display = "none";
                document.getElementById(MAP_DIVS[2].id).style.display = "initial";
                activeMap = MAP_DIVS[2].id;
                setSliderDates(combinedStartYear, combinedEndYear);
            }
            // Function calls to change style of active toggle button and re-color active map
            styleActiveToggleBtn();
        }

        // Get toggle btns and assign them to array, then restyle their colors
        function styleActiveToggleBtn() {
            var btns = Array.from(document.getElementsByClassName("toggle_btn"));
            btns.forEach(b => {
                if (b.value == activeMap) {
                    b.style.backgroundColor = "steelblue";
                    b.style.borderColor = "steelblue";
                }
                else {
                    b.style.backgroundColor = "cornflowerblue";
                    b.style.borderColor = "cornflowerblue";
                }
            });
        }

        // Define function to create toggle map btns
        function createToggleBtn(parentDiv, divControlled, btnText, toggleFunc) {
            var btn = document.createElement("button");
            btn.classList.add("toggle_btn");
            btn.innerText = btnText;
            btn.value = divControlled;
            btn.onclick = function () { toggleFunc(divControlled) };
            document.getElementById(parentDiv).appendChild(btn);
            return btn;
        }

        // Create the map display toggle btns
        let toggleValueBtn = createToggleBtn("control_overlay", "home_values", "Change in Home Values", toggleMap);
        let toggleIncomeBtn = createToggleBtn("control_overlay", "incomes", "Change in Incomes", toggleMap);
        let toggleCombinedBtn = createToggleBtn("control_overlay", "combined", "Housing Market Health", toggleMap);

        // Define function to create Date range slider control input
        function dualSliderInput(div, min, max, changeYears) {
            // Create single dual-input range slider made of two normal sliders
            var s1 = document.createElement("input");
            var s2 = document.createElement("input");
            s1.classList.add("range_slider");
            s2.classList.add("range_slider");
            s1.name = "s1";
            s2.name = "s2";
            s1.type = s2.type = "range"
            s1.min = s2.min = min;
            s1.max = s2.max = max;
            s1.step = s2.step = 1;
            // Create text display divs to append their input text to
            var t1 = document.createElement("div");
            var t2 = document.createElement("div");
            t1.classList.add("text_box");
            t2.classList.add("text_box");
            t1.id = "t1";
            t2.id = "t2";
            // Add functionality to sliders
            s1.onmouseup = function () { changeYears(s1.value, s2.value) };
            s2.onmouseup = function () { changeYears(s1.value, s2.value) };
            // append everything to the parent (control) div in the right order
            document.getElementById(div).appendChild(t1);
            document.getElementById(div).appendChild(s2);
            document.getElementById(div).appendChild(s1);
            document.getElementById(div).appendChild(t2);
            return [s1, s2, t1, t2];
        }

        // Additional slider control logic--
        // Repositions sliders during a page toggle & 
        // ensures both sliders control as a single dual slider 
        function controlSlider(start = null, end = null) {
            var s1 = document.getElementsByName("s1")[0];
            var s2 = document.getElementsByName("s2")[0];
            // If arguments were provided, overide controls and set sliders to arguments
            if (start != null && end != null) {
                s1.value = start;
                s2.value = end
            }
            // Else control using dual-slider control logic
            else if (s2.value > s1.value) {
                s1.style.display = "initial";
                s2.style.display = "initial";
            }
            else if (this == s2 && s2.value < s1.value) {
                s1.value = s2.value;
                s1.style.display = "none";
            }
            else if (this == s1 && s1.value > s2.value) {
                s2.value = s1.value;
                s2.style.display = "none";
            }
            // update the slider text box divs to display the years
            updateTextBox(s1.value, s2.value)
        }

        // Updates the date slider's text boxes with their input value 
        function updateTextBox(value1, value2) {
            let textBox1 = document.getElementById("t1");
            let textBox2 = document.getElementById("t2");
            textBox1.innerHTML = value1;
            textBox2.innerHTML = value2;
        }

        // Passes slider values as arguments to to controlSlider Func
        function setSliderDates(start, end) {
            controlSlider(start, end)
        }

        // Create the date input range-sliders
        let dateSlider = dualSliderInput("control_overlay", 2010, 2020, changeYears);
        // Add event listeners & their associated control logic
        dateSlider[0].addEventListener("input", controlSlider);
        dateSlider[1].addEventListener("input", controlSlider);

        // Init the page upon initial load
        function initPage(startYearDefault, endYearDefault) {
            for (var i = 0; i < Object.keys(MAP_DIVS).length; i++) {
                toggleMap(MAP_DIVS[i].id);
                dataUpdateHandler(startYearDefault, endYearDefault);
            }
            toggleMap(MAP_DIVS[0].id);
        }
        // Init default pages with 2020 as start and end year
        initPage(2020, 2020)
    });

</script>


</html>